public static RestTemplate create() throws Exception {

        // Load your certificate
        CertificateFactory cf = CertificateFactory.getInstance("X.509");

        InputStream certStream = SecureRestTemplate.class
                .getResourceAsStream("/certs/myserver.crt");

        X509Certificate caCert = (X509Certificate) cf.generateCertificate(certStream);

        // Create a KeyStore with your trusted certificate
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(null, null);
        ks.setCertificateEntry("myserver", caCert);

        // Build SSLContext using only your certificate
        SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();
        sslContextBuilder.loadTrustMaterial(ks, null);

        SSLConnectionSocketFactory socketFactory =
                new SSLConnectionSocketFactory(sslContextBuilder.build());

        CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLSocketFactory(socketFactory)
                .build();

        HttpComponentsClientHttpRequestFactory requestFactory =
                new HttpComponentsClientHttpRequestFactory(httpClient);

        return new RestTemplate(requestFactory);
    }
}
Usage:

java
Copy code
RestTemplate restTemplate = SecureRestTemplate.create();
String response = restTemplate.getForObject("https://your-secure-api", String.class);
âœ” This will trust only your certificate
âœ” Safe for production

âœ… Option 2 â€” Use a JKS truststore (recommended for enterprise)
If you already have:

truststore.jks

or want to create one using your certificate

1. Create truststore using keytool
pgsql
Copy code
keytool -import -alias myserver \
  -file myserver.crt \
  -keystore truststore.jks
Set password when prompted.

2. Use truststore with RestTemplate
java
Copy code
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContextBuilder;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import java.io.FileInputStream;
import java.security.KeyStore;

public class TrustStoreRestTemplate {

    public static RestTemplate create() throws Exception {

        String truststorePath = "/path/to/truststore.jks";
        char[] password = "changeit".toCharArray(); // your password

        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(new FileInputStream(truststorePath), password);

        SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();
        sslContextBuilder.loadTrustMaterial(trustStore, null);

        SSLConnectionSocketFactory socketFactory =
                new SSLConnectionSocketFactory(sslContextBuilder.build());

        CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLSocketFactory(socketFactory)
                .build();

        HttpComponentsClientHttpRequestFactory requestFactory =
                new HttpComponentsClientHttpRequestFactory(httpClient);

        return new RestTemplate(requestFactory);
    }
}
ðŸ”¥ Which approach should you use?
Approach	When to Use
Load certificate directly (Option 1)	Quick setup when you only have .crt/.pem file
Truststore (Option 2)	Enterprise, multiple certificates, DevOps-friendly

If you want, I can generate:
âœ” A Spring @Configuration with a @Bean RestTemplate
âœ” A version for Spring WebClient
âœ” Steps to convert PEM â†’ JKS
âœ” How to debug SSL handshake failures

Tell me what you need!









@Service
public class FileCompareService {

    @Value("${file.folder.base-path}")
    private String baseFolderPath;  // e.g. /data/files/

    private final FileRecordRepository fileRecordRepository;

    public FileCompareService(FileRecordRepository fileRecordRepository) {
        this.fileRecordRepository = fileRecordRepository;
    }

    public String compareFolderWithTable(String dateStr) {

        LocalDate date = LocalDate.parse(dateStr);

        String folderPath = baseFolderPath + "/" + dateStr;

        Map<String, Integer> fileToCount = readFiles(folderPath);

        Map<String, Integer> tableData = readFromTable(date);

        Set<String> files = fileToCount.keySet();
        Set<String> tableFiles = tableData.keySet();

        Set<String> inFolderNotInTable = new TreeSet<>(files);
        inFolderNotInTable.removeAll(tableFiles);

        Set<String> inTableNotInFolder = new TreeSet<>(tableFiles);
        inTableNotInFolder.removeAll(files);

        Set<String> mismatch = new TreeSet<>();
        for (String f : files) {
            if (tableFiles.contains(f)) {
                if (!Objects.equals(fileToCount.get(f), tableData.get(f))) {
                    mismatch.add(f);
                }
            }
        }

        // build response text
        StringBuilder sb = new StringBuilder();
        sb.append("=== FILES IN FOLDER BUT NOT IN TABLE ===\n");
        inFolderNotInTable.forEach(f -> sb.append(f).append("\n"));

        sb.append("\n=== FILES IN TABLE BUT NOT IN FOLDER ===\n");
        inTableNotInFolder.forEach(f -> sb.append(f).append("\n"));

        sb.append("\n=== COUNT MISMATCH (fileCount vs tableCount) ===\n");
        mismatch.forEach(f ->
            sb.append(f)
              .append(" : file=")
              .append(fileToCount.get(f))
              .append(", table=")
              .append(tableData.get(f))
              .append("\n")
        );

        return sb.toString();
    }

    private Map<String, Integer> readFiles(String folderPath) {
        Map<String, Integer> result = new HashMap<>();
        Path path = Paths.get(folderPath);

        if (!Files.exists(path)) {
            return result;
        }

        try (Stream<Path> paths = Files.list(path)) {
            paths.filter(Files::isRegularFile).forEach(p -> {
                try {
                    List<String> lines = Files.readAllLines(p);

                    long nonEmptyCount = lines.stream()
                        .map(String::trim)
                        .filter(s -> !s.isEmpty())
                        .count();

                    if (nonEmptyCount > 0) nonEmptyCount--; // subtract header

                    result.put(p.getFileName().toString(), (int) nonEmptyCount);

                } catch (Exception e) {
                    System.err.println("Error reading file " + p + ": " + e.getMessage());
                }
            });
        } catch (Exception e) {
            System.err.println("Error listing folder: " + e.getMessage());
        }

        return result;
    }

    private Map<String, Integer> readFromTable(LocalDate date) {
        List<FileRecord> records = fileRecordRepository.findByDate(date);

        Map<String, Integer> map = new HashMap<>();
        for (FileRecord r : records) {
            map.put(r.getFileName(), r.getRecordCount());
        }
        return map;
    }
}

@RestController
@RequestMapping("/api/claims")
public class ClaimDocumentController {

    @Autowired
    private FileStorageService fileStorageService;

    @PostMapping("/{claimId}/documents")
    public ResponseEntity<?> uploadDocuments(
            @PathVariable String claimId,
            @RequestParam("files") List<MultipartFile> files) {

        List<String> uploadedFiles = fileStorageService.storeFiles(claimId, files);
        return ResponseEntity.ok(uploadedFiles);
    }
}


spring.servlet.multipart.max-file-size=-1
spring.servlet.multipart.max-request-size=-1

# Where to store files
files.storage.location=C:/claim-documents

@Entity
@Table(name = "claim_documents")
public class ClaimDocument {

    @Id
    private String id;   // UUID

    @Column(name = "claim_id")
    private String claimId;

    @Column(name = "original_name")
    private String originalName;

    @Column(name = "file_size")
    private long fileSize;

    @Column(name = "content_type")
    private String contentType;

    @Column(name = "extension")
    private String extension;

    @Column(name = "upload_time")
    private LocalDateTime uploadTime;
}

public interface ClaimDocumentRepository extends JpaRepository<ClaimDocument, String> {

    List<ClaimDocument> findByClaimId(String claimId);
}

@Service
public class FileStorageService {

    @Value("${files.storage.location}")
    private String basePath;

    @Autowired
    private ClaimDocumentRepository repo;

    public List<String> storeFiles(String claimId, List<MultipartFile> files) {

        Path claimFolder = Paths.get(basePath, claimId).toAbsolutePath().normalize();
        try {
            Files.createDirectories(claimFolder);
        } catch (IOException ignored) { }

        List<String> storedIds = new ArrayList<>();

        for (MultipartFile file : files) {
            if (file.isEmpty()) continue;

            String uuid = UUID.randomUUID().toString();
            Path targetLocation = claimFolder.resolve(uuid);  // Store as UUID only

            // Stream file to disk
            try (InputStream is = file.getInputStream();
                 OutputStream os = Files.newOutputStream(targetLocation)) {

                byte[] buffer = new byte[8192];
                int len;
                while ((len = is.read(buffer)) != -1) {
                    os.write(buffer, 0, len);
                }

            } catch (Exception e) {
                throw new RuntimeException("Could not store file", e);
            }

            // Save metadata
            ClaimDocument meta = new ClaimDocument();
            meta.setId(uuid);
            meta.setClaimId(claimId);
            meta.setOriginalName(file.getOriginalFilename());
            meta.setFileSize(file.getSize());
            meta.setContentType(file.getContentType());
            meta.setExtension(getExtension(file.getOriginalFilename()));
            meta.setUploadTime(LocalDateTime.now());

            repo.save(meta);
            storedIds.add(uuid);
        }

        return storedIds;
    }

    private String getExtension(String fileName) {
        if (fileName == null) return "";
        int idx = fileName.lastIndexOf('.');
        return idx > 0 ? fileName.substring(idx + 1) : "";
    }
}

@GetMapping("/{claimId}/documents")
public ResponseEntity<List<ClaimDocument>> listDocuments(@PathVariable String claimId) {
    return ResponseEntity.ok(repo.findByClaimId(claimId));
}

@GetMapping("/documents/{fileId}")
public ResponseEntity<Resource> download(@PathVariable String fileId) {

    ClaimDocument meta = repo.findById(fileId)
            .orElseThrow(() -> new RuntimeException("File not found"));

    Path filePath = Paths.get(basePath, meta.getClaimId(), meta.getId());

    Resource resource;
    try {
        resource = new UrlResource(filePath.toUri());
        if (!resource.exists()) {
            throw new RuntimeException("File missing on disk");
        }
    } catch (Exception e) {
        throw new RuntimeException("Could not read file");
    }

    return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(meta.getContentType()))
            .header(HttpHeaders.CONTENT_DISPOSITION,
                    "attachment; filename=\"" + meta.getOriginalName() + "\"")
            .body(resource);
}




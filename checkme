spring.mail.host=smtp.example.com
spring.mail.port=587
spring.mail.username=no-reply@example.com
spring.mail.password=secret
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

mail.from=no-reply@example.com
mail.to=to@example.com
mail.cc=cc@example.com


@Service
public class EmailService {

    private final JavaMailSender mailSender;

    @Value("${mail.from}")
    private String from;

    @Value("${mail.to}")
    private String to;

    @Value("${mail.cc}")
    private String cc;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendEmail(String body) {

        String finalBody = buildEmailBody(body);

        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(from);
        message.setTo(to.split(","));   // supports multiple recipients
        message.setCc(cc.split(","));
        message.setSubject("Notification");
        message.setText(finalBody);

        mailSender.send(message);
    }

    private String buildEmailBody(String body) {
        return new StringBuilder()
                .append("Hi,\n\n")
                .append(body)
                .append("\n\nRegards,\n")
                .toString();
    }
}
3️⃣ How to call the method
java
Copy code
emailService.sendEmail("This is the email body content.");
4️⃣ Notes (important for backend systems)
✅ Why this approach is correct
Uses Spring-managed JavaMailSender

Properties externalized (no hardcoding)

Supports multiple TO / CC emails

Thread-safe and reusable

Easy to unit test (mock JavaMailSender)

5️⃣ Optional enhancements (if you want)
HTML email (MimeMessageHelper)

Attachments

Dynamic subject

Retry on failure

Async sending (@Async)

Multiple environments (dev/prod SMTP)

If you want HTML version or attachment support, tell me — I’ll extend this cleanly.








